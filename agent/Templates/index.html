<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>BlackHole â€” Code Analyzer</title>
<style>
:root{--bg1:#0f1226;--bg2:#0b1630;--muted:#4d5866;--accent:#7c5cff}
body{margin:0;font-family:Inter,system-ui,Segoe UI,Arial;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:#e6eef8}
.app{padding:20px;max-width:1200px;margin:0 auto}
.header{display:flex;justify-content:space-between;align-items:center;gap:12px}
.controls{display:flex;gap:8px;align-items:center}
.btn{padding:8px 12px;border-radius:8px;border:0;cursor:pointer;font-weight:700}
.btn-primary{background:linear-gradient(90deg,var(--accent),#6b9bff);color:#071029}
.card{background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;margin-top:12px}
#tableContent{max-height:360px;overflow:auto;margin-top:8px}
.panel-grid{display:flex;gap:12px;margin-top:12px}
.panel{flex:1;min-height:140px;overflow:auto;padding:10px;background:#ffffff;color:#111;border-radius:8px}
.panel .title{font-weight:700;margin-bottom:6px}
.small{font-size:13px;color:var(--muted)}
/* Table styling: white background, dark text for readability */
#tableContent table{width:100%;border-collapse:collapse;background:#ffffff;color:#111;table-layout:fixed}
#tableContent th, #tableContent td{padding:8px;border:1px solid #e6e6e6;vertical-align:top}
#tableContent th{background:#f7f7f7;color:#222;text-align:left}
#tableContent td{color:#222;white-space:normal;word-break:break-word;overflow-wrap:break-word}

/* Column widths: name (30%), type (12%), result (8%), duration (10%), info (remaining) */
#tableContent th:nth-child(1), #tableContent td:nth-child(1){width:30%}
#tableContent th:nth-child(2), #tableContent td:nth-child(2){width:12%}
#tableContent th:nth-child(3), #tableContent td:nth-child(3){width:8%}
#tableContent th:nth-child(4), #tableContent td:nth-child(4){width:10%}
#tableContent th:nth-child(5), #tableContent td:nth-child(5){width:40%}

/* Progress bar */
.progress-wrap{display:flex;flex-direction:column;gap:6px;min-width:220px}
.progress{height:8px;background:rgba(255,255,255,0.08);border-radius:6px;overflow:hidden}
.progress > i{display:block;height:100%;width:0;background:linear-gradient(90deg,var(--accent),#6b9bff);transition:width .25s}
.progressText{font-size:12px;color:var(--muted)}

</style>
</head>
<body>
<div class="app">
    <div class="header">
        <div>
            <div style="font-weight:800;font-size:20px">Analysis Results</div>
            <div id="lastUpdated" class="small">No results yet</div>
        </div>
        <div style="display:flex;align-items:center;gap:12px">
            <div class="controls">
                <input id="fileInput" type="file" accept=".zip" style="display:none">
                <button id="chooseBtn" class="btn">Choose</button>
                <button id="uploadBtn" class="btn btn-primary">Upload & Analyze</button>
            </div>
            <div class="progress-wrap">
                <div class="progress"><i id="progressBar"></i></div>
                <div id="progressText" class="progressText">Idle</div>
            </div>
        </div>
    </div>

    <div id="tableCard" class="card">
        <div style="font-weight:700">Test Case Table</div>
        <div id="tableContent" class="small">No test results yet.</div>
    </div>

    <div class="panel-grid">
        <div id="staticContent" class="panel">
            <div class="title">Static</div>
            <pre class="small" id="staticBody">No static results.</pre>
        </div>
        <div id="dynamicContent" class="panel">
            <div class="title">Dynamic</div>
            <pre class="small" id="dynamicBody">No dynamic results.</pre>
        </div>
    </div>

    <div class="panel-grid">
        <div id="whiteBox" class="panel" style="display:none">
            <div class="title">White Box Tests</div>
            <div class="small" id="whiteBody">White-box summary will appear here.</div>
        </div>
        <div id="blackBox" class="panel" style="display:none">
            <div class="title">Black Box Tests</div>
            <div class="small" id="blackBody">Black-box summary will appear here.</div>
        </div>
    </div>
</div>

<script>
// Simple, robust client script
const fileInput = document.getElementById('fileInput');
const chooseBtn = document.getElementById('chooseBtn');
const uploadBtn = document.getElementById('uploadBtn');
const tableContent = document.getElementById('tableContent');
const staticBody = document.getElementById('staticBody');
const dynamicBody = document.getElementById('dynamicBody');
const whiteBody = document.getElementById('whiteBody');
const blackBody = document.getElementById('blackBody');
const lastUpdated = document.getElementById('lastUpdated');

chooseBtn.addEventListener('click', ()=>fileInput.click());
fileInput.addEventListener('change', ()=>{ chooseBtn.textContent = fileInput.files.length ? fileInput.files[0].name : 'Choose' });

function safeText(s){ if(!s) return ''; return String(s); }

function setProgress(p, msg){
    const pb = document.getElementById('progressBar');
    const pt = document.getElementById('progressText');
    if(pb) pb.style.width = Math.max(0, Math.min(100, p||0)) + '%';
    if(pt) pt.textContent = msg || '';
}

function renderResult(res){
    // Normalize tests from different producers so UI shows a consistent table.
    const structuredTests = (res && res.dynamic_structured && Array.isArray(res.dynamic_structured.tests)) ? res.dynamic_structured.tests : [];
    // generated_tests may be an array or an object with `tests` array
    const generatedRaw = (res && res.generated_tests) ? (Array.isArray(res.generated_tests) ? res.generated_tests : (res.generated_tests.tests || [])) : [];

    const normalize = (t, origin) => {
        // t can have many shapes: {test, status, detail}, {name, result}, or simple strings
        if(!t) return { name: '', type: '', result: '', duration_ms: '', info: '' };
        if(typeof t === 'string') return { name: t, type:'', result:'', duration_ms:'', info:'' };
        const name = t.name || t.test || t.title || t.id || t.titleText || '';
        const result = t.result || t.status || t.state || '';
        const duration_ms = t.duration_ms || t.duration || t.time_ms || '';
        // Heuristics for test type/category
        let type = t.type || (String(name||'').toLowerCase().includes('equiv') ? 'equivalence' : (t.meta || ''));
        const lname = String(name||'').toLowerCase();
        // Prefer detailed output fields, fall back to commands (array or string)
        let info = '';
        if(t.detail) info = t.detail;
        else if(t.info) info = t.info;
        else if(t.output) info = t.output;
        else if(t.command) info = (Array.isArray(t.command) ? t.command.join(' ; ') : String(t.command));
        else if(t.commands) info = (Array.isArray(t.commands) ? t.commands.join(' ; ') : String(t.commands));
        else info = '';
        if(!type){
            if(lname.includes('boundary') || lname.includes('edge') || lname.includes('limit')) type = 'boundary';
            else if(lname.includes('env') || lname.includes('environment') || lname.includes('readme') || lname.includes('env test')) type = 'environment';
            else if(lname.includes('resource') || lname.includes('memory') || lname.includes('leak')) type = 'resource';
            else if(lname.includes('concurrency') || lname.includes('thread') || lname.includes('race')) type = 'concurrency';
            else if(lname.startsWith('tc-') || lname.startsWith('tc') || lname.includes('test case') || lname.includes('tc-')) type = 'functional';
            else if(lname.includes('equiv') || lname.includes('equivalence')) type = 'equivalence';
            else if(lname.startsWith('check_') || lname.startsWith('check') || lname.startsWith('check-')) type = 'check';
            else if(lname.startsWith('injected_') || lname.includes('injected')) type = 'injected';
            else type = '';
        }
        // Infer category: white-box vs black-box. Prefer explicit meta otherwise heuristics.
        let category = '';
        if(t.meta && String(t.meta).toLowerCase().includes('white')) category = 'White-box';
        else if(t.meta && String(t.meta).toLowerCase().includes('black')) category = 'Black-box';
        else if(String(type).toLowerCase() === 'equivalence' || String(type).toLowerCase() === 'functional' || String(type).toLowerCase() === 'boundary') category = 'Black-box';
        else if(String(type).toLowerCase() === 'resource' || String(type).toLowerCase() === 'concurrency' || String(type).toLowerCase() === 'environment') category = 'White-box';
        else category = '';
        // Further inspect commands to improve category inference
        try{
            const cmds = (t && (t.commands || t.command)) || '';
            const cmdStr = Array.isArray(cmds) ? cmds.join(' ') : String(cmds||'');
            const lcmd = cmdStr.toLowerCase();
            if(!category){
                if(lcmd.includes('test -f') || lcmd.includes('test -n') || lcmd.includes('clangd') || lcmd.includes('qmake') || lcmd.includes('.pro') ){
                    category = 'White-box';
                }
                if(lcmd.includes('echo') || lcmd.includes('tc-') || lcmd.includes('tc ')){
                    if(!category) category = 'Black-box';
                }
            }
        }catch(e){ }
        // determine origin label
        let originLabel = '';
        try{
            if(origin === 'dynamic') originLabel = 'Dynamic';
            else originLabel = 'Generated';
            // if commands look like static checks, mark as Static
            const cmds2 = (t && (t.commands || t.command)) || '';
            const cmdAll = Array.isArray(cmds2) ? cmds2.join(' ') : String(cmds2||'');
            const lc = cmdAll.toLowerCase();
            if(lc.includes('qmake') || lc.includes('.pro') || lc.includes('clangd') || lc.includes('test -f') || (String(name||'').toLowerCase().startsWith('check_'))){
                originLabel = 'Static';
            }
        }catch(e){ }

        // Ensure every row has a result value. Infer from info when missing, else mark PENDING.
        let resVal = String(result || '');
        try{
            if(!resVal || resVal.trim() === ''){
                const infoLower = String(info||'').toLowerCase();
                if(/\b(pass|ok|succeed|success)\b/.test(infoLower)) resVal = 'PASS';
                else if(/\b(fail|failed|error|exception|crash|exiting with code|not found|missing)\b/.test(infoLower)) resVal = 'FAIL';
                else if(originLabel === 'Static' && /found\s+\d+\s+c\/?c\+\+\s+error-level/.test(infoLower)) resVal = 'FAIL';
                else resVal = 'PENDING';
            }
        }catch(e){ resVal = resVal || 'PENDING'; }

        return { name: String(name||''), type: String(type||''), category: category, origin: originLabel, result: String(resVal), duration_ms: duration_ms, info: String(info||'') };
    };

    const all = [];
    const seen = new Set();
    structuredTests.forEach(t => {
        const n = normalize(t, 'dynamic');
        const key = (n.name||n.info||n.result).toString();
        if(!seen.has(key)){
            seen.add(key);
            all.push(n);
        }
    });
    generatedRaw.forEach(t => {
        const n = normalize(t, 'generated');
        const key = (n.name||n.info||n.result).toString();
        if(!seen.has(key)){
            seen.add(key);
            all.push(n);
        }
    });

    if(all.length){
        const hasDuration = all.some(r => r.duration_ms && String(r.duration_ms).trim() !== '');
        const tbl = document.createElement('table');
        const h = document.createElement('tr');
        const headers = ['Name','Type','Result'];
        if(hasDuration) headers.push('Duration');
        headers.push('Info');
        headers.forEach(t => { const th = document.createElement('th'); th.textContent = t; h.appendChild(th); });
        tbl.appendChild(h);
        all.forEach(row => {
            const tr = document.createElement('tr');
            const name = document.createElement('td'); name.textContent = safeText(row.name||'');
            const type = document.createElement('td');
            const originPart = row.origin ? (row.origin + ' / ') : '';
            const typeText = originPart + (row.type||'') + (row.category ? (' ('+row.category+')') : '');
            type.textContent = safeText(typeText);
            const rescol = document.createElement('td'); rescol.textContent = safeText(row.result||'');
            const cells = [name, type, rescol];
            if(hasDuration){
                const dur = document.createElement('td'); dur.textContent = row.duration_ms ? (Number(row.duration_ms)/1000).toFixed(2)+'s' : '';
                cells.push(dur);
            }
            const info = document.createElement('td'); info.textContent = safeText(row.info||'');
            cells.push(info);
            cells.forEach(n => tr.appendChild(n));
            tbl.appendChild(tr);
        });
        tableContent.innerHTML = ''; tableContent.appendChild(tbl);
        // hide white/black boxes if table contains test cases
        const wb = document.getElementById('whiteBox');
        const bb = document.getElementById('blackBox');
        if(wb) wb.style.display = 'none';
        if(bb) bb.style.display = 'none';
    } else if(res && res.ui_html){
        tableContent.innerHTML = '<div class="small">'+(res.ui_html||'')+'<div style="margin-top:8px"><a href="ui_report.html" target="_blank">View full report</a></div></div>';
    } else {
        tableContent.textContent = 'No test results available.';
    }

    // Show white/black panels only when we have a processed result but no table rows
    try{
        const wb = document.getElementById('whiteBox');
        const bb = document.getElementById('blackBox');
        if(res){
            if(all.length === 0){
                if(wb) wb.style.display = 'block';
                if(bb) bb.style.display = 'block';
            } else {
                if(wb) wb.style.display = 'none';
                if(bb) bb.style.display = 'none';
            }
        } else {
            // no result yet: keep them hidden
            if(wb) wb.style.display = 'none';
            if(bb) bb.style.display = 'none';
        }
    }catch(e){ /* ignore */ }

    // analysis summaries (show full static result if available)
    try{
        if(res && res.static_full){
            staticBody.textContent = res.static_full;
        } else if(res && (res.static || res.static_summary && res.static_summary.raw)){
            staticBody.textContent = (res.static || (res.static_summary && res.static_summary.raw));
        } else {
            staticBody.textContent = 'No static results.';
        }
    }catch(e){ staticBody.textContent = 'No static results.'; }
    dynamicBody.textContent = (res && (res.dynamic_text||res.dynamic_raw||res.dynamic)) ? ( (res.dynamic_text||res.dynamic_raw||res.dynamic).split('\n').slice(0,300).join('\n') ) : 'No dynamic results.';

    const whiteCount = all.filter(t => (t.category||'').toString().toLowerCase().includes('white')).length;
    const blackCount = all.filter(t => (t.category||'').toString().toLowerCase().includes('black')).length;
    whiteBody.textContent = `White-box tests: ${whiteCount}.`;
    blackBody.textContent = `Black-box tests: ${blackCount}.`;

    lastUpdated.textContent = new Date().toLocaleString();

    // Show a short static summary line above the detailed static output so
    // users see the error count at a glance while still seeing full details.
    try{
        let shortSummary = '';
        if(res && res.ui_left && res.ui_left.static) shortSummary = res.ui_left.static;
        else if(res && res.white_box && res.white_box.summary) shortSummary = res.white_box.summary;
        else if(res && res.static_summary && res.static_summary.raw){
            // try to extract a concise first-line summary
            const lines = String(res.static_summary.raw||'').split('\n');
            shortSummary = lines[0] || '';
        }
        const full = res && (res.static_full || res.static || (res.static_summary && res.static_summary.raw)) ? (res.static_full || res.static || (res.static_summary && res.static_summary.raw)) : '';
        if(shortSummary){
            staticBody.textContent = shortSummary + '\n\n' + (full || '');
        } else if(full){
            staticBody.textContent = full;
        } else {
            staticBody.textContent = 'No static results.';
        }
    }catch(e){ staticBody.textContent = 'No static results.'; }
}

async function pollStatus(ws){
    try{
        const r = await fetch('/status?ws='+encodeURIComponent(ws));
        const d = await r.json();
        // update progress if provided
        if(d && (typeof d.progress === 'number')){
            setProgress(d.progress, d.message || d.status || 'Processing');
        } else if(d && d.status){
            setProgress(60, d.status);
        }
        if(d && (d.status==='Done' || d.status==='done')){ renderResult(d.result||d); setProgress(100, 'Complete'); return true; }
    }catch(e){ console.error('pollStatus', e); setProgress(0,'Error'); }
    return false;
}

uploadBtn.addEventListener('click', async ()=>{
    if(!fileInput.files.length) return alert('Choose a zip first');
    uploadBtn.disabled = true; uploadBtn.textContent = 'Uploading...'; setProgress(10,'Uploading...');
    const fd = new FormData(); fd.append('file', fileInput.files[0]);
    try{
        const r = await fetch('/upload', { method:'POST', body: fd });
        const j = await r.json();
        if(!j || j.status!=='Accepted' || !j.workspace){ alert('Upload failed'); uploadBtn.disabled=false; uploadBtn.textContent='Upload & Analyze'; return; }
        const ws = j.workspace; setProgress(30,'Queued'); let done=false; const iv = setInterval(async ()=>{ done = await pollStatus(ws); if(done){ clearInterval(iv); uploadBtn.disabled=false; uploadBtn.textContent='Upload & Analyze'; setProgress(100,'Complete'); } }, 1500);
    }catch(e){ alert('Upload error: '+e); uploadBtn.disabled=false; uploadBtn.textContent='Upload & Analyze'; }
});
</script>
</body>
</html>
