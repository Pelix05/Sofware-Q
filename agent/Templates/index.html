<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>BlackHole ‚Äî Code Analyzer</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
<style>
:root{
    --bg1:#0f1226; --bg2:#0b1630; --card:#0f1724; --accent:#7c5cff; --accent-2:#00d4ff; --muted:#9aa4bf; --glass: rgba(255,255,255,0.03);
}
*{box-sizing:border-box;font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial}
html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:#e6eef8}
.app{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:28px}
.frame{width:100%;max-width:1400px;border-radius:14px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 10px 40px rgba(2,6,23,0.7);overflow:hidden;display:flex;gap:0}
.sidebar{width:36%;min-width:320px;padding:24px 28px;background:linear-gradient(135deg, rgba(124,92,255,0.06), rgba(0,212,255,0.02));backdrop-filter: blur(6px);}
.content{flex:1;padding:28px;display:flex;flex-direction:column;gap:16px}
.brand{display:flex;align-items:center;gap:12px;margin-bottom:6px}
.logo{width:48px;height:48px;border-radius:10px;background:linear-gradient(135deg,var(--accent),var(--accent-2));display:flex;align-items:center;justify-content:center;font-weight:800;color:#071029}
.title{font-size:18px;font-weight:800}
.subtitle{font-size:13px;color:var(--muted);margin-top:2px}
.section{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:10px;padding:14px;border:1px solid rgba(255,255,255,0.03)}
.file-area{display:flex;flex-direction:column;gap:12px}
.drop{display:flex;align-items:center;gap:12px;padding:14px;border-radius:10px;border:1px dashed rgba(255,255,255,0.05);background:var(--glass);cursor:pointer}
.drop:hover{border-color:rgba(124,92,255,0.35)}
.file-meta{display:flex;align-items:center;justify-content:space-between;gap:10px}
.file-meta #wsInfo{max-width:220px;white-space:normal;word-break:break-word;overflow-wrap:anywhere}
.btn{display:inline-flex;align-items:center;gap:10px;padding:10px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:700}
.btn-primary{background:linear-gradient(90deg,var(--accent),#6b9bff);color:#071029}
.btn-ghost{background:transparent;border:1px solid rgba(255,255,255,0.03);color:var(--muted)}
.controls{display:flex;gap:10px}
.progress-wrap{margin-top:8px}
.progress{height:12px;background:rgba(255,255,255,0.04);border-radius:8px;overflow:hidden}
.progress > i{display:block;height:100%;width:0;background:linear-gradient(90deg,var(--accent),var(--accent-2));transition:width .25s}
.status-line{font-size:13px;color:var(--muted);margin-top:8px}

/* right side */
.results{display:flex;flex-direction:column;gap:14px}
.card{background:linear-gradient(180deg, rgba(6,9,20,0.6), rgba(6,9,20,0.45));border-radius:10px;padding:14px;border:1px solid rgba(255,255,255,0.03);min-height:80px}
.results .card.code{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', monospace;white-space:pre-wrap;overflow:auto;max-height:520px;word-break:break-word;overflow-wrap:anywhere}
.card .small, .card .detail {white-space:normal;word-break:break-word;overflow-wrap:anywhere}
.analysis-grid, .analysis-grid > * {min-width:0}
.analysis-panel{box-sizing:border-box}
.analysis-panel .small{white-space:normal}
.analysis-panel.code{white-space:normal}
.panel-title{color:#cfe6ff}
.panel-body{white-space:normal;word-break:break-word;overflow-wrap:anywhere}

/* Ensure injected tables fit the card and wrap cells */
#tableContent table{width:100% !important; table-layout: fixed !important; border-collapse: collapse;}
#tableContent th, #tableContent td{white-space:normal; word-break:break-word; overflow-wrap:anywhere; padding:6px; border:1px solid rgba(255,255,255,0.04)}
#tableContent{max-width:100%; box-sizing:border-box}

/* file name wrap */
#fileName{max-width:220px; white-space:normal; word-break:break-word; overflow-wrap:anywhere}
.header-row{display:flex;align-items:center;justify-content:space-between;gap:12px}
.small{font-size:13px;color:var(--muted)}
.badge{padding:6px 10px;border-radius:999px;font-weight:700}
.badge.pass{background:rgba(10,160,90,0.12);color:#7ef3b6}
.badge.fail{background:rgba(255,80,80,0.06);color:#ffb4b4}
.badge.info{background:rgba(124,92,255,0.06);color:#bfb4ff}

/* responsiveness */
@media(max-width:920px){.frame{flex-direction:column}.sidebar{width:100%;min-width:unset}.content{padding:18px}.analysis-grid{flex-direction:column} }
</style>
</head>
<body>
<div class="app">
    <div class="frame">
        <div class="sidebar">
            <div class="brand">
                </div>
            
                <!-- Upload block moved into sidebar so left column stacks upload then analysis -->
                <div class="section file-area" style="margin-top:12px">
                    <label class="small">Upload Project (ZIP)</label>
                            <div id="dropArea" class="drop">
                        <input id="fileInput" type="file" accept=".zip" style="display:none">
                        <div style="flex:1">
                            <div id="fileName" style="font-weight:700;color:#dfe9ff">No file selected</div>
                            <div style="font-size:12px;color:var(--muted);margin-top:6px">Drag & drop or click to choose.</div>
                        </div>
                        <div>
                            <button id="chooseBtn" class="btn btn-ghost">Choose</button>
                        </div>
                    </div>

                    <div class="file-meta">
                        <div class="controls">
                            <button id="uploadBtn" class="btn btn-primary">Upload & Analyze</button>
                        </div>
                        <div class="small" id="wsInfo">No workspace</div>
                    </div>

                    <div class="progress-wrap">
                        <div class="progress"><i id="progressBar"></i></div>
                        <div class="status-line" id="progressText">Idle</div>
                    </div>
                </div>

                <!-- Moved: Static & Dynamic Analysis card now lives in the left sidebar under upload -->
                <div id="analysisCard" class="section card" style="margin-top:12px;padding:12px;">
                    <div style="font-weight:700;margin-bottom:6px">Static &amp; Dynamic Analysis</div>
                    <div class="analysis-grid" style="display:flex;gap:12px;align-items:stretch;">
                        <div id="staticContent" class="analysis-panel" style="flex:1;padding:10px;border-radius:8px;background:rgba(255,255,255,0.01);max-height:300px;overflow:auto;display:flex;flex-direction:column;">
                            <div class="panel-title" style="font-weight:700;margin-bottom:6px;font-size:13px">Static</div>
                            <div class="panel-body small" style="flex:1;overflow:auto">Results will appear here.</div>
                        </div>
                    </div>
                    <!-- Simplified: hide White-box/Black-box panels and keep Static then Unit Tests in place -->
                    <div style="margin-top:12px;">
                        <div id="unitTestBox" class="analysis-panel" style="padding:10px;border-radius:8px;background:rgba(255,255,255,0.01);max-height:260px;overflow:auto;display:flex;flex-direction:column;">
                            <div class="panel-title" style="font-weight:700;margin-bottom:6px;font-size:13px">Unit Tests</div>
                            <div class="panel-body small" style="flex:1;overflow:auto">Unit test results will appear here.</div>
                        </div>
                    </div>
                    <div id="leftSummary" style="margin-top:10px;font-size:13px;color:var(--muted)"></div>
                </div>

            </div>

            <div class="content">

        <div class="content">
            <div class="header-row">
                <div style="display:flex;align-items:center;gap:12px">
                    <div style="font-weight:800;font-size:20px">Analysis Results</div>
                    <div class="small" id="lastUpdated">No results yet</div>
                </div>
                <div style="display:flex;align-items:center;gap:8px">
                    <div id="summaryBadge" class="badge info">Idle</div>
                </div>
            </div>

            <div class="results">
                <!-- Table card now occupies the entire right column and is larger -->
                <div id="tableCard" class="card" style="margin-top:6px;overflow:hidden;flex:1;display:flex;flex-direction:column;">
                    <div style="font-weight:700;margin-bottom:8px">Test Case Table</div>
                    <div id="tableContent" class="small" style="flex:1;overflow:auto;display:block;box-sizing:border-box;max-height:calc(100vh - 220px);">The test results table will appear here when available.</div>
                </div>
            </div>

        </div>
    </div>
</div>

<script>
const fileInput = document.getElementById('fileInput');
const chooseBtn = document.getElementById('chooseBtn');
const dropArea = document.getElementById('dropArea');
const fileName = document.getElementById('fileName');
const uploadBtn = document.getElementById('uploadBtn');
const progressBar = document.getElementById('progressBar');
const progressText = document.getElementById('progressText');
const wsInfo = document.getElementById('wsInfo');
const staticContent = document.getElementById('staticContent');
const tableContent = document.getElementById('tableContent');
const summaryBadge = document.getElementById('summaryBadge');
const lastUpdated = document.getElementById('lastUpdated');

chooseBtn.addEventListener('click', () => fileInput.click());
fileInput.addEventListener('change', () => {
    fileName.textContent = fileInput.files.length ? fileInput.files[0].name : 'No file selected';
});

dropArea.addEventListener('dragover', e => { e.preventDefault(); dropArea.style.borderColor = 'rgba(124,92,255,0.35)'; });
dropArea.addEventListener('dragleave', e => { dropArea.style.borderColor = 'rgba(255,255,255,0.03)'; });
dropArea.addEventListener('drop', e => { e.preventDefault(); dropArea.style.borderColor = 'rgba(255,255,255,0.03)'; if (e.dataTransfer.files.length) { fileInput.files = e.dataTransfer.files; fileName.textContent = e.dataTransfer.files[0].name; }});

function setProgress(p, msg){ progressBar.style.width = (p||0) + '%'; progressText.textContent = msg || '' }

async function pollStatus(ws){
    try{
        const s = await fetch('/status?ws=' + encodeURIComponent(ws));
        const sd = await s.json();
        const prog = (sd && typeof sd.progress === 'number') ? sd.progress : (sd && sd.progress ? parseInt(sd.progress) : null);
        const msg = (sd && sd.message) ? sd.message : (sd && sd.status ? sd.status : 'Processing');
        if (prog!==null && !isNaN(prog)) setProgress(prog, msg);
        else setProgress(30, msg);

        if (sd && (sd.status === 'Done' || sd.status === 'done' || sd.status === 'Complete' || sd.status === 'complete')){
            setProgress(100,'Complete');
            summaryBadge.className = 'badge pass'; summaryBadge.textContent = 'Complete';
            lastUpdated.textContent = new Date().toLocaleString();
            // fetch full (truncated) result explicitly to avoid large payloads on frequent polls
            setTimeout(async ()=>{
                try{
                    const r2 = await fetch('/status?ws=' + encodeURIComponent(ws) + '&include_result=1');
                    const rd = await r2.json();
                    const res = rd.result || rd;
                    renderResult(res);
                }catch(e){
                    // fallback to any result embedded in status
                    try{ const res = sd.result || sd; renderResult(res);}catch(_){}
                }
            }, 500);
            return true;
        }
        if (sd && (sd.status=== 'Error' || sd.status==='error')){ summaryBadge.className='badge fail'; summaryBadge.textContent='Error'; tableContent.textContent = sd.error || 'Processing error'; return true }
        // update summary
        summaryBadge.className='badge info'; summaryBadge.textContent = msg || 'Processing';
        return false;
    }catch(e){ summaryBadge.className='badge fail'; summaryBadge.textContent='Poll failed'; tableContent.textContent = ''+e; return true }
}

function highlight(s){ if(!s) return ''; return String(s).replace(/PASS/g,'<span style="color:#7ef3b6;font-weight:800">PASS</span>').replace(/FAIL/g,'<span style="color:#ffb4b4;font-weight:800">FAIL</span>') }

// Escape HTML to safely insert text nodes
function escapeHtml(unsafe){
    if(unsafe === null || unsafe === undefined) return '';
    return String(unsafe)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
}

function renderResult(res){
    if(!res) return;
    wsInfo.textContent = res.workspace || 'workspace';
    // Populate static panel with a concise static-summary: tool header, total issues and top issue lines
    const statBody = staticContent.querySelector('.panel-body');
    const staticRaw = (res.static && (typeof res.static === 'string' ? res.static : (res.static.cppcheck || res.static.raw || ''))) || (res.static_summary && res.static_summary.raw) || '';

    try{
        if(statBody){
            if(staticRaw && staticRaw.trim()){
                // Extract first line as tool header and try to find a "Found <N>" pattern
                const firstLine = (staticRaw.split(/\r?\n/)[0] || '').trim();
                const foundMatch = staticRaw.match(/Found\s+(\d+)\s+/i) || staticRaw.match(/Found:\s*(\d+)/i);
                const issueCount = foundMatch ? Number(foundMatch[1]) : null;
                // Separate errors and warnings and present counts + samples
                const allLines = staticRaw.split(/\r?\n/);
                // filter out noisy traceback / runtime messages that are not analyzer findings
                const noiseRe = /\b(Traceback|raise\s+|TypeError|JSON serializable|Object of type)\b/i;
                const fileIssueRe = /([^\s:]+\.(?:cpp|cc|c|hpp|hh|h))(?:[:\(]\d+)?/i;
                const issueTokenRe = /\b(error|warning|fatal|undefined reference)\b/i;
                const errorLines = allLines.filter(l => !noiseRe.test(l) && (fileIssueRe.test(l) || issueTokenRe.test(l) && /[:\\/]/.test(l)) && /error|fatal|undefined reference/i.test(l));
                const warningLines = allLines.filter(l => !noiseRe.test(l) && (fileIssueRe.test(l) || issueTokenRe.test(l) && /[:\\/]/.test(l)) && /warning/i.test(l));

                let html = '<div style="font-weight:700;margin-bottom:6px">Static Analysis</div>';
                if(firstLine) html += '<div style="font-size:12px;color:var(--muted);margin-bottom:8px">' + escapeHtml(firstLine) + '</div>';
                // Do not display numeric counts in the Static panel; show generic label
                html += '<div style="margin-bottom:8px;color:var(--muted);font-size:12px">Static Analysis</div>';

                // Show counts and the full static report; avoid duplicating 'top' lists
                statBody.innerHTML = html + '<div style="font-weight:700;margin-top:10px;margin-bottom:6px">Full Static Report</div>' +
                    '<pre class="card code small" style="max-height:240px;overflow:auto;margin-top:6px;white-space:pre-wrap;">' + escapeHtml(staticRaw) + '</pre>';
            } else {
                statBody.innerHTML = '<div style="color:var(--muted)">No static analysis output available.</div>';
            }
        }
    }catch(e){ console.warn('Static render failed', e); }
    // White-box / Black-box panels removed per UI simplification.
    // ‚úÖ Êñ∞Â¢ûÔºöÊ∏≤ÊüìÂçïÂÖÉÊµãËØïÁªìÊûú
    try{
        const unitTestBox = document.getElementById('unitTestBox');
        const utBody = unitTestBox && unitTestBox.querySelector('.panel-body');
        const unitTests = res.unit_tests || (res.white_box && res.white_box.unit_tests) || null;
        
        if(utBody){
            if(unitTests && unitTests.status === 'completed'){
                let html = '<div style="font-weight:700;color:#7ef3b6">‚úÖ ' + escapeHtml(unitTests.summary || 'Tests passed') + '</div>';
                html += '<div style="margin-top:8px;display:flex;gap:16px;font-size:12px;color:var(--muted)">';
                html += '<div>Total: <span style="color:#dfe9ff;font-weight:700">' + (unitTests.total || 0) + '</span></div>';
                html += '<div>Passed: <span style="color:#7ef3b6;font-weight:700">' + (unitTests.passed || 0) + '</span></div>';
                html += '<div>Failed: <span style="color:#ffb4b4;font-weight:700">' + (unitTests.failed || 0) + '</span></div>';
                html += '<div>Pass Rate: <span style="color:#dfe9ff;font-weight:700">' + (unitTests.pass_rate || 0) + '%</span></div>';
                html += '</div>';
                if(unitTests.log_file){
                    html += '<div style="margin-top:8px"><a href="/workspaces/' + encodeURIComponent(res.workspace || '') + '/' + escapeHtml(unitTests.log_file) + '" target="_blank" style="color:var(--accent);text-decoration:none;font-size:12px">üìÑ View Test Log</a></div>';
                }
                utBody.innerHTML = html;
            } else if(unitTests && unitTests.status === 'skipped'){
                utBody.innerHTML = '<div style="color:var(--muted)">‚ö†Ô∏è ' + escapeHtml(unitTests.summary || 'Unit tests were skipped') + '</div>';
            } else if(unitTests && unitTests.status === 'failed'){
                utBody.innerHTML = '<div style="color:#ffb4b4">‚ùå ' + escapeHtml(unitTests.summary || 'Unit tests failed') + '</div>';
            } else if(unitTests && unitTests.status === 'error'){
                utBody.innerHTML = '<div style="color:#ffb4b4">‚ö†Ô∏è ' + escapeHtml(unitTests.summary || 'Unit test error') + '</div>';
            } else {
                utBody.innerHTML = '<div style="color:var(--muted)">Unit test results not available</div>';
            }
        }
    }catch(e){ /* non-fatal */ }
    // Populate compact left-side summary (static count + perf short)
    try{
        const leftSummary = document.getElementById('leftSummary');
            if(leftSummary){
            const ui_left = res.ui_left || {};
            const staticText = ui_left.static || '';
            const perfText = ui_left.perf || '';
            let ls = '';
            // show a non-numeric static label instead of counts
            if(staticText) ls += '<div style="font-weight:700;margin-bottom:4px">Static Analysis</div>';
            if(perfText) ls += '<div style="color:var(--muted);font-size:12px">' + escapeHtml(perfText) + '</div>';
            if(!ls) ls = '<div style="color:var(--muted)">No summary available</div>';
            leftSummary.innerHTML = ls;
        }
    }catch(e){ /* ignore */ }
    // Build consolidated test list and render table with Number, Name, Type, Priority, Status
    try{
        const tests = [];
        // 1) Unit tests summary as one entry (White-box)
        const unitTests = res.unit_tests || (res.white_box && res.white_box.unit_tests) || null;
        if(unitTests){
            const status = (unitTests.status === 'completed') ? 'PASS' : (unitTests.status || 'N/A');
            const failed = unitTests.failed || 0;
            const total = unitTests.total || 0;
            const name = 'Unit Tests Summary';
            const priority = (failed>0) ? 'High' : ((total>0) ? 'Medium' : 'Low');
            tests.push({name, type: 'White-box (Unit)', priority, status: status, details: unitTests});
        }
        // 2) Dynamic structured tests if available
        if(res.dynamic_structured && Array.isArray(res.dynamic_structured.tests)){
            res.dynamic_structured.tests.forEach(t => {
                const name = t.test || t.name || 'Unnamed Test';
                const st = (t.status||'').toString().toUpperCase() || 'N/A';
                const pr = t.priority || (st==='FAIL' ? 'High' : (st==='PASS' ? 'Medium' : 'Low'));
                tests.push({name, type: 'Black-box (Dynamic)', priority: pr, status: st});
            });
        }
        // 3) Generated tests (functional)
        if(res.generated_tests){
            try{
                const g = Array.isArray(res.generated_tests) ? res.generated_tests : (res.generated_tests.tests || []);
                (g || []).forEach((t, idx) => {
                    const name = t.test || t.name || ('Generated Test ' + (idx+1));
                    tests.push({name, type: 'Functional (Generated)', priority: t.priority || 'Low', status: (t.status||'N/A').toString().toUpperCase()});
                });
            }catch(e){ }
        }
        // 4) Static issues as separate rows (take top N lines that look like issues)
        const staticTxt = (res.static) || (res.static_summary && res.static_summary.raw) || '';
        if(staticTxt){
            const sLines = staticTxt.split(/\r?\n/).filter(l => {
                const noiseRe = /\b(Traceback|raise\s+|TypeError|JSON serializable|Object of type)\b/i;
                const fileIssueRe = /([^\s:]+\.(?:cpp|cc|c|hpp|hh|h))(?:[:\(]\d+)?/i;
                const issueTokenRe = /\b(error|warning|fatal|undefined reference)\b/i;
                if(noiseRe.test(l)) return false;
                if(fileIssueRe.test(l)) return true;
                if(issueTokenRe.test(l) && /[:\\/]/.test(l)) return true;
                return false;
            });
                for(let i=0;i<Math.min(10,sLines.length);i++){
                const ln = sLines[i].trim();
                const name = ln.split(/[:\-]/).slice(0,3).join(' ').slice(0,120) || ('Static issue ' + (i+1));
                tests.push({name, type: 'Static (Analysis)', priority: 'High', status: 'N/A', details: ln});
            }
        }
        // 5) Perf report: expose multiple perf metrics as separate test rows
        if(res.perf){
            try{
                const pf = res.perf;
                if(pf.cpu_bench_ms != null){
                    tests.push({name: 'CPU micro-bench (median): ' + (Math.round(pf.cpu_bench_ms*10)/10) + ' ms', type: 'Performance', priority: 'Medium', status: 'N/A'});
                }
                if(pf.cpu_bench_runs_ms && Array.isArray(pf.cpu_bench_runs_ms)){
                    tests.push({name: 'CPU micro-bench runs: ' + pf.cpu_bench_runs_ms.map(v=>Math.round(v)).join(', ') + ' ms', type: 'Performance', priority: 'Low', status: 'N/A'});
                }
                if(pf.mt_cpu_bench_ms != null){
                    tests.push({name: 'Multi-thread CPU (4 threads): ' + (Math.round(pf.mt_cpu_bench_ms*10)/10) + ' ms', type: 'Performance', priority: 'Medium', status: 'N/A'});
                }
                if(pf.io_benchmark){
                    const io = pf.io_benchmark;
                    tests.push({name: 'I/O write median: ' + (io.write_ms_median ? Math.round(io.write_ms_median*10)/10 + ' ms' : 'N/A'), type: 'Performance', priority: 'Low', status: 'N/A'});
                    tests.push({name: 'I/O read median: ' + (io.read_ms_median ? Math.round(io.read_ms_median*10)/10 + ' ms' : 'N/A'), type: 'Performance', priority: 'Low', status: 'N/A'});
                }
                if(pf.alloc_benchmark && pf.alloc_benchmark.alloc_ms != null){
                    tests.push({name: 'Allocation micro-bench: ' + (Math.round(pf.alloc_benchmark.alloc_ms*10)/10) + ' ms', type: 'Performance', priority: 'Low', status: 'N/A'});
                }
                if(pf.mem_usage_kb != null){
                    tests.push({name: 'Memory RSS: ' + (Math.round((pf.mem_usage_kb/1024.0)*10)/10) + ' MB (' + (pf.mem_usage_kb||0) + ' KB)', type: 'Performance', priority: 'Low', status: 'N/A'});
                }
            }catch(e){ /* ignore */ }
        }

        // Remove duplicates and ensure no empty rows/columns
        const finalTests = [];
        const seen = new Set();
        tests.forEach(t => {
            const key = (t.name||'') + '|' + (t.type||'') + '|' + (t.status||'');
            if(!key.trim()) return;
            if(!seen.has(key)){
                seen.add(key);
                finalTests.push({
                    name: t.name || 'N/A',
                    type: t.type || 'N/A',
                    priority: t.priority || 'N/A',
                    status: t.status || 'N/A'
                });
            }
        });

        // Render table with numbering and no empty cells
            if(finalTests.length){
            let html = '<table><thead><tr><th style="width:6%">#</th><th style="width:46%">Test Case</th><th style="width:18%">Type</th><th style="width:15%">Priority</th><th style="width:15%">Status</th></tr></thead><tbody>';
            finalTests.forEach((t, i) => {
                html += '<tr>';
                html += '<td>' + (i+1) + '</td>';
                html += '<td>' + escapeHtml(t.name || 'N/A') + '</td>';
                html += '<td>' + escapeHtml(t.type || 'N/A') + '</td>';
                html += '<td>' + escapeHtml(t.priority || 'N/A') + '</td>';
                html += '<td>' + escapeHtml(t.status || 'N/A') + '</td>';
                html += '</tr>';
            });
            html += '</tbody></table>';
            // build perf summary HTML if present (user-friendly labels)
            let perfHtml = '';
            let perfDetailsHtml = '';
            try{
                if(res.perf){
                    const pf = res.perf;
                    const kbToMb = (kb) => (kb ? Math.round((kb/1024.0)*10)/10 : null);
                    const rows = [];
                    if(pf.cpu_bench_ms != null) rows.push(['CPU (median)', Math.round(pf.cpu_bench_ms*10)/10 + ' ms']);
                    if(pf.cpu_bench_runs_ms && Array.isArray(pf.cpu_bench_runs_ms)) rows.push(['CPU (runs)', pf.cpu_bench_runs_ms.map(v=>Math.round(v)).join(', ') + ' ms']);
                    if(pf.mt_cpu_bench_ms != null) rows.push(['Multi-thread CPU', Math.round(pf.mt_cpu_bench_ms*10)/10 + ' ms']);
                    if(pf.io_benchmark){ const io = pf.io_benchmark; rows.push(['I/O write (median)', io.write_ms_median!=null ? Math.round(io.write_ms_median*10)/10 + ' ms' : 'N/A']); rows.push(['I/O read (median)', io.read_ms_median!=null ? Math.round(io.read_ms_median*10)/10 + ' ms' : 'N/A']); }
                    if(pf.alloc_benchmark && pf.alloc_benchmark.alloc_ms != null) rows.push(['Alloc time', Math.round(pf.alloc_benchmark.alloc_ms*10)/10 + ' ms']);
                    if(pf.mem_usage_kb != null) rows.push(['Memory RSS', (kbToMb(pf.mem_usage_kb) !== null ? (kbToMb(pf.mem_usage_kb) + ' MB') : '') + ' (' + (pf.mem_usage_kb||'') + ' KB)']);
                    if(pf.load_test){ const lt = pf.load_test || {}; rows.push(['Load test', (lt.requests||0) + ' reqs, conc ' + (lt.concurrency||0) + ', avg ' + (lt.avg_latency_ms!=null ? (Math.round(lt.avg_latency_ms*10)/10 + ' ms') : 'N/A') + ', success ' + (lt.success||0)]); }
                    // render as compact key/value list
                    perfHtml = '<div style="font-weight:700;margin-bottom:6px">Performance Summary</div><div class="panel-body small" style="background:rgba(255,255,255,0.01);padding:10px;border-radius:6px;margin-bottom:8px;">';
                    rows.forEach(r => { perfHtml += '<div style="display:flex;justify-content:space-between;gap:12px"><div style="color:var(--muted);font-size:12px">' + escapeHtml(r[0]) + '</div><div style="font-weight:700">' + escapeHtml(r[1]) + '</div></div>'; });
                    perfHtml += '</div>';

                    // Detailed per-executable results (from perf.results) shown above the table
                    if(pf.results && typeof pf.results === 'object'){
                        perfDetailsHtml = '<div style="font-weight:700;margin-bottom:6px">Detailed Performance (per executable)</div>';
                        Object.keys(pf.results).forEach(exeName => {
                            const ex = pf.results[exeName] || {};
                            perfDetailsHtml += '<div style="margin-bottom:8px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.01)">';
                            perfDetailsHtml += '<div style="font-weight:700;margin-bottom:6px">' + escapeHtml(exeName) + '</div>';
                            // benchmark
                            if(ex.benchmark){
                                const b = ex.benchmark;
                                perfDetailsHtml += '<div style="display:flex;gap:12px;margin-bottom:6px"><div style="color:var(--muted);font-size:12px">Benchmark</div><div style="font-weight:700">' + (b.cpu_bench_ms!=null ? (Math.round(b.cpu_bench_ms*10)/10 + ' ms') : 'N/A') + '</div></div>';
                            }
                            // concurrency
                            if(ex.concurrency){
                                const c = ex.concurrency;
                                perfDetailsHtml += '<div style="display:flex;gap:12px;margin-bottom:6px"><div style="color:var(--muted);font-size:12px">Concurrency</div><div style="font-weight:700">' + (c.cpu_bench_ms!=null ? (Math.round(c.cpu_bench_ms*10)/10 + ' ms') : 'N/A') + '</div></div>';
                            }
                            // load steps
                            if(ex.load && ex.load.steps){
                                perfDetailsHtml += '<div style="font-weight:700;margin-bottom:4px">Load Steps</div><div style="max-height:120px;overflow:auto;margin-bottom:6px">';
                                ex.load.steps.slice(0,20).forEach(s => {
                                    const sum = s.summary || {};
                                    const val = sum.cpu_bench_ms!=null ? (Math.round(sum.cpu_bench_ms*10)/10 + ' ms') : (sum.cpu_bench_runs_ms ? sum.cpu_bench_runs_ms.map(v=>Math.round(v)).join(', ') + ' ms' : (s.error||'N/A'));
                                    perfDetailsHtml += '<div style="display:flex;justify-content:space-between;gap:12px"><div style="color:var(--muted);font-size:12px">Concurrency ' + escapeHtml(String(s.concurrency)) + '</div><div style="font-weight:700">' + escapeHtml(String(val)) + '</div></div>';
                                });
                                perfDetailsHtml += '</div>';
                            }
                            // stress
                            if(ex.stress && ex.stress.attempts){
                                perfDetailsHtml += '<div style="font-weight:700;margin-top:6px">Stress Attempts</div>';
                                const concl = ex.stress.conclusion || '';
                                perfDetailsHtml += '<div style="color:var(--muted);font-size:12px;margin-bottom:6px">' + escapeHtml(concl) + '</div>';
                            }
                            // soak
                            if(ex.soak){
                                const so = ex.soak;
                                perfDetailsHtml += '<div style="font-weight:700;margin-top:6px">Soak</div>';
                                perfDetailsHtml += '<div style="color:var(--muted);font-size:12px">duration: ' + escapeHtml(String(so.duration_s || so.duration || 'N/A')) + 's, failures: ' + escapeHtml(String(so.failures || 0)) + ', median: ' + escapeHtml(String(so.median_latency_ms || 'N/A')) + ' ms</div>';
                            }
                            perfDetailsHtml += '</div>';
                        });
                    }
                }
            }catch(e){ perfHtml=''; perfDetailsHtml=''; }
                    tableContent.innerHTML = perfDetailsHtml + perfHtml + html;
        } else {
            // if no tests, still try to show perf or raw ui but avoid empty placeholders
                    if(res.perf){
                        const perfPre = (perfDetailsHtml || '') + perfHtml + '<div style="margin-bottom:8px;font-weight:700">Performance Report</div><pre class="small">' + escapeHtml(JSON.stringify(res.perf, null, 2)) + '</pre>';
                        tableContent.innerHTML = perfPre;
            } else if(res.ui_html || (res.ui_summary && res.ui_summary.ui_html)){
                tableContent.innerHTML = res.ui_html || res.ui_summary.ui_html;
            } else {
                tableContent.innerHTML = '<div style="color:var(--muted)">No test cases detected.</div>';
            }
        }
    }catch(e){ console.warn('Table render failed', e); }
    // end renderResult
}

uploadBtn.addEventListener('click', async ()=>{
    if (!fileInput.files.length) return alert('Choose a zip first');
    uploadBtn.disabled = true; uploadBtn.textContent = 'Uploading...'; setProgress(6,'Uploading');
    const fd = new FormData(); fd.append('file', fileInput.files[0]);
    try{
        const r = await fetch('/upload',{method:'POST',body:fd});
        const d = await r.json();
        if (d.status !== 'Accepted' || !d.workspace){ alert('Upload failed: ' + (d.error||JSON.stringify(d))); uploadBtn.disabled=false; uploadBtn.textContent='Upload & Analyze'; setProgress(0,'Idle'); return }
        const ws = d.workspace; wsInfo.textContent = ws; setProgress(20,'Queued');
        // poll until done
        const interval = 1500;
        const t = setInterval(async ()=>{ const done = await pollStatus(ws); if(done){ clearInterval(t); uploadBtn.disabled=false; uploadBtn.textContent='Upload & Analyze'; } }, interval);
    }catch(e){ alert('Upload error: '+e); uploadBtn.disabled=false; uploadBtn.textContent='Upload & Analyze'; setProgress(0,'Idle') }
});

// quick action hooks removed (buttons were removed from UI)

</script>
</body>
</html>
