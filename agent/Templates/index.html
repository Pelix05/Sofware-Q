<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>BlackHole — Code Analyzer</title>
<style>
:root{--bg1:#0f1226;--bg2:#0b1630;--muted:#4d5866;--accent:#7c5cff}
body{margin:0;font-family:Inter,system-ui,Segoe UI,Arial;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:#e6eef8}
.app{padding:20px;max-width:1200px;margin:0 auto}
.header{display:flex;justify-content:space-between;align-items:center;gap:12px}
.controls{display:flex;gap:8px;align-items:center}
.btn{padding:8px 12px;border-radius:8px;border:0;cursor:pointer;font-weight:700}
.btn-primary{background:linear-gradient(90deg,var(--accent),#6b9bff);color:#071029}
.card{background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;margin-top:12px}
#tableContent{max-height:360px;overflow:auto;margin-top:8px}
.panel-grid{display:flex;gap:12px;margin-top:12px}
.panel{flex:1;min-height:140px;overflow:auto;padding:10px;background:#ffffff;color:#111;border-radius:8px}
.panel .title{font-weight:700;margin-bottom:6px}
.small{font-size:13px;color:var(--muted)}
/* Table styling: white background, dark text for readability */
#tableContent table{width:100%;border-collapse:collapse;background:#ffffff;color:#111;table-layout:fixed}
#tableContent th, #tableContent td{padding:8px;border:1px solid #e6e6e6;vertical-align:top}
#tableContent th{background:#f7f7f7;color:#222;text-align:left}
#tableContent td{color:#222;white-space:normal;word-break:break-word;overflow-wrap:break-word}

/* Column widths: name (30%), type (12%), result (8%), duration (10%), info (remaining) */
#tableContent th:nth-child(1), #tableContent td:nth-child(1){width:30%}
#tableContent th:nth-child(2), #tableContent td:nth-child(2){width:12%}
#tableContent th:nth-child(3), #tableContent td:nth-child(3){width:8%}
#tableContent th:nth-child(4), #tableContent td:nth-child(4){width:10%}
#tableContent th:nth-child(5), #tableContent td:nth-child(5){width:40%}

/* Progress bar */
.progress-wrap{display:flex;flex-direction:column;gap:6px;min-width:220px}
.progress{height:8px;background:rgba(255,255,255,0.08);border-radius:6px;overflow:hidden}
.progress > i{display:block;height:100%;width:0;background:linear-gradient(90deg,var(--accent),#6b9bff);transition:width .25s}
.progressText{font-size:12px;color:var(--muted)}

</style>
</head>
<body>
<div class="app">
    <div class="header">
        <div>
            <div style="font-weight:800;font-size:20px">Analysis Results</div>
            <div id="lastUpdated" class="small">No results yet</div>
        </div>
        <div style="display:flex;align-items:center;gap:12px">
            <div class="controls">
                <input id="fileInput" type="file" accept=".zip" style="display:none">
                <button id="chooseBtn" class="btn">Choose</button>
                <button id="uploadBtn" class="btn btn-primary">Upload & Analyze</button>
            </div>
            <div class="progress-wrap">
                <div class="progress"><i id="progressBar"></i></div>
                <div id="progressText" class="progressText">Idle</div>
            </div>
        </div>
    </div>

    <div id="tableCard" class="card">
        <div id="tableContent" class="small">No test results yet.</div>
    </div>

    <div class="panel-grid">
        <div id="staticContent" class="panel">
            <div class="title">Static</div>
            <pre class="small" id="staticBody">No static results.</pre>
        </div>
        <div id="dynamicContent" class="panel">
            <div class="title">Dynamic</div>
            <pre class="small" id="dynamicBody">No dynamic results.</pre>
        </div>
    </div>

    <div class="panel-grid">
        <div id="whiteBox" class="panel" style="display:none">
            <div class="title">White Box Tests</div>
            <div class="small" id="whiteBody">White-box summary will appear here.</div>
        </div>
        <div id="blackBox" class="panel" style="display:none">
            <div class="title">Black Box Tests</div>
            <div class="small" id="blackBody">Black-box summary will appear here.</div>
        </div>
    </div>
</div>

<script>
// Simple, robust client script
const fileInput = document.getElementById('fileInput');
const chooseBtn = document.getElementById('chooseBtn');
const uploadBtn = document.getElementById('uploadBtn');
const tableContent = document.getElementById('tableContent');
const staticBody = document.getElementById('staticBody');
const dynamicBody = document.getElementById('dynamicBody');
const whiteBody = document.getElementById('whiteBody');
const blackBody = document.getElementById('blackBody');
const lastUpdated = document.getElementById('lastUpdated');

chooseBtn.addEventListener('click', ()=>fileInput.click());
fileInput.addEventListener('change', ()=>{ chooseBtn.textContent = fileInput.files.length ? fileInput.files[0].name : 'Choose' });

function safeText(s){ if(!s) return ''; return String(s); }

function setProgress(p, msg){
    const pb = document.getElementById('progressBar');
    const pt = document.getElementById('progressText');
    if(pb) pb.style.width = Math.max(0, Math.min(100, p||0)) + '%';
    if(pt) pt.textContent = msg || '';
}

function renderResult(res){
    // Normalize tests from different producers so UI shows a consistent table.
    const structuredTests = (res && res.dynamic_structured && Array.isArray(res.dynamic_structured.tests)) ? res.dynamic_structured.tests : [];
    // generated_tests may be an array or an object with `tests` array
    const generatedRaw = (res && res.generated_tests) ? (Array.isArray(res.generated_tests) ? res.generated_tests : (res.generated_tests.tests || [])) : [];
    // unit_tests merged by Flask (workspace-level unified tests)
    const unitTests = (res && res.unit_tests && Array.isArray(res.unit_tests)) ? res.unit_tests : [];

    const normalize = (t, origin) => {
        // t can have many shapes: {test, status, detail}, {name, result}, or simple strings
        if(!t) return { name: '', type: '', result: '', duration_ms: '', info: '' };
        if(typeof t === 'string') return { name: t, type:'', result:'', duration_ms:'', info:'' };
        const name = t.name || t.test || t.title || t.id || t.titleText || '';
        const result = t.result || t.status || t.state || '';
        const duration_ms = t.duration_ms || t.duration || t.time_ms || '';
        // Heuristics for test type/category
        let type = t.type || (String(name||'').toLowerCase().includes('equiv') ? 'equivalence' : (t.meta || ''));
        const lname = String(name||'').toLowerCase();
        // Prefer detailed output fields, fall back to commands (array or string)
        let info = '';
        if(t.detail) info = t.detail;
        else if(t.info) info = t.info;
        else if(t.output) info = t.output;
        else if(t.command) info = (Array.isArray(t.command) ? t.command.join(' ; ') : String(t.command));
        else if(t.commands) info = (Array.isArray(t.commands) ? t.commands.join(' ; ') : String(t.commands));
        else info = '';
        if(!type){
            if(lname.includes('boundary') || lname.includes('edge') || lname.includes('limit')) type = 'boundary';
            else if(lname.includes('env') || lname.includes('environment') || lname.includes('readme') || lname.includes('env test')) type = 'environment';
            else if(lname.includes('resource') || lname.includes('memory') || lname.includes('leak')) type = 'resource';
            else if(lname.includes('concurrency') || lname.includes('thread') || lname.includes('race')) type = 'concurrency';
            else if(lname.startsWith('tc-') || lname.startsWith('tc') || lname.includes('test case') || lname.includes('tc-')) type = 'functional';
            else if(lname.includes('equiv') || lname.includes('equivalence')) type = 'equivalence';
            else if(lname.startsWith('check_') || lname.startsWith('check') || lname.startsWith('check-')) type = 'check';
            else if(lname.startsWith('injected_') || lname.includes('injected')) type = 'injected';
            else type = '';
        }
        // Infer category: white-box vs black-box. Prefer explicit meta otherwise heuristics.
        let category = '';
        if(t.meta && String(t.meta).toLowerCase().includes('white')) category = 'White-box';
        else if(t.meta && String(t.meta).toLowerCase().includes('black')) category = 'Black-box';
        else if(String(type).toLowerCase() === 'equivalence' || String(type).toLowerCase() === 'functional' || String(type).toLowerCase() === 'boundary') category = 'Black-box';
        else if(String(type).toLowerCase() === 'resource' || String(type).toLowerCase() === 'concurrency' || String(type).toLowerCase() === 'environment') category = 'White-box';
        else category = '';
        // Further inspect commands to improve category inference
        try{
            const cmds = (t && (t.commands || t.command)) || '';
            const cmdStr = Array.isArray(cmds) ? cmds.join(' ') : String(cmds||'');
            const lcmd = cmdStr.toLowerCase();
            if(!category){
                if(lcmd.includes('test -f') || lcmd.includes('test -n') || lcmd.includes('clangd') || lcmd.includes('qmake') || lcmd.includes('.pro') ){
                    category = 'White-box';
                }
                if(lcmd.includes('echo') || lcmd.includes('tc-') || lcmd.includes('tc ')){
                    if(!category) category = 'Black-box';
                }
            }
        }catch(e){ }
        // determine origin label
        let originLabel = '';
        try{
            if(origin === 'dynamic') originLabel = 'Dynamic';
            else originLabel = 'Generated';
            // if commands look like static checks, mark as Static
            const cmds2 = (t && (t.commands || t.command)) || '';
            const cmdAll = Array.isArray(cmds2) ? cmds2.join(' ') : String(cmds2||'');
            const lc = cmdAll.toLowerCase();
            if(lc.includes('qmake') || lc.includes('.pro') || lc.includes('clangd') || lc.includes('test -f') || (String(name||'').toLowerCase().startsWith('check_'))){
                originLabel = 'Static';
            }
        }catch(e){ }

        // Ensure every row has a result value. Infer from info when missing, else mark PENDING.
        let resVal = String(result || '');
        try{
            if(!resVal || resVal.trim() === ''){
                const infoLower = String(info||'').toLowerCase();
                if(/\b(pass|ok|succeed|success)\b/.test(infoLower)) resVal = 'PASS';
                else if(/\b(fail|failed|error|exception|crash|exiting with code|not found|missing)\b/.test(infoLower)) resVal = 'FAIL';
                else if(originLabel === 'Static' && /found\s+\d+\s+c\/?c\+\+\s+error-level/.test(infoLower)) resVal = 'FAIL';
                else resVal = 'PENDING';
            }
        }catch(e){ resVal = resVal || 'PENDING'; }

        return { name: String(name||''), type: String(type||''), category: category, origin: originLabel, result: String(resVal), duration_ms: duration_ms, info: String(info||'') };
    };

    const all = [];
    const seen = new Set();
    structuredTests.forEach(t => {
        const n = normalize(t, 'dynamic');
        const key = (n.name||n.info||n.result).toString();
        if(!seen.has(key)){
            seen.add(key);
            all.push(n);
        }
    });
    generatedRaw.forEach(t => {
        const n = normalize(t, 'generated');
        const key = (n.name||n.info||n.result).toString();
        if(!seen.has(key)){
            seen.add(key);
            all.push(n);
        }
    });

    if(all.length){
        // Prefer server-provided ui_summary rows (structured for table display)
        const uiRows = (res && res.ui_summary && Array.isArray(res.ui_summary.rows)) ? res.ui_summary.rows : null;
        const tbl = document.createElement('table');
        const h = document.createElement('tr');
        // Desired columns: 定义编号、测试类型、输入、预期输出、结果、详情
        const headers = ['定义编号','测试类型','输入','预期输出','结果','详情'];
        headers.forEach(t => { const th = document.createElement('th'); th.textContent = t; h.appendChild(th); });
        tbl.appendChild(h);

        if(uiRows){
            uiRows.forEach(row => {
                const tr = document.createElement('tr');
                const namec = document.createElement('td'); namec.textContent = safeText(row.id || row.test || row.title || 'N/A');
                const typec = document.createElement('td'); typec.textContent = safeText((row.type || row.description || '').toString());
                const rescol = document.createElement('td'); rescol.textContent = safeText(row.status || row.result || 'N/A');
                [namec, typec, rescol].forEach(n => tr.appendChild(n));
                tbl.appendChild(tr);
            });
        } else {
            // fallback to earlier 'all' normalized rows
            // Build a combined normalized list: structured, generated, and unit_tests
            const combined = [];
            structuredTests.forEach(t=>combined.push(normalize(t,'dynamic')));
            generatedRaw.forEach(t=>combined.push(normalize(t,'generated')));
            unitTests.forEach(t=>combined.push(normalize(t,'unit')));

            // Build headers for the 3-column table to match content (replace existing header row)
            const headerRow = h;
            headerRow.innerHTML = '';
            ['测试','测试类型','结果/指标'].forEach(label => { const th = document.createElement('th'); th.textContent = label; headerRow.appendChild(th); });

            // dedupe when merging combined items (by normalized name + mapped type)
            const seenRows = new Set();

            // improved performance info renderer: parse JSON, numeric metrics, or show a short summary
            const renderPerfInfo = (r) => {
                try{
                    // prefer explicit duration metric
                    if(r.duration_ms) return `Avg: ${Number(r.duration_ms).toFixed(3)} ms`;
                    const txt = (r.info||'').toString().trim();
                    if(!txt) return String(r.result || 'N/A');

                    // If the info is JSON PERF_METRICS, parse and format nicely
                    try{
                        const obj = JSON.parse(txt);
                        if(obj && typeof obj === 'object'){
                            const parts = [];
                            // what was tested
                            if(r.name) parts.push(`Test: ${r.name}`);
                            // runs / count
                            if(obj.count !== undefined) parts.push(`Runs: ${obj.count}`);
                            // show measurements array (shorten if long)
                            if(Array.isArray(obj.measurements_ms)){
                                const meas = obj.measurements_ms.slice(0,8).join(', ');
                                parts.push(`Measurements(ms): [${meas}${obj.measurements_ms.length>8? ', ...':''}]`);
                            }
                            if(obj.avg_ms !== undefined) parts.push(`Avg: ${Number(obj.avg_ms).toFixed(3)} ms`);
                            if(obj.min_ms !== undefined) parts.push(`Min: ${obj.min_ms} ms`);
                            if(obj.max_ms !== undefined) parts.push(`Max: ${obj.max_ms} ms`);
                            if(obj.throughput_ops_per_s !== undefined) parts.push(`Throughput: ${obj.throughput_ops_per_s} ops/s`);
                            // include any other numeric hints
                            const known = new Set(['measurements_ms','count','avg_ms','min_ms','max_ms','throughput_ops_per_s']);
                            Object.keys(obj).forEach(k=>{
                                if(!known.has(k)) parts.push(`${k}: ${obj[k]}`);
                            });
                            return parts.join(' | ');
                        }
                    }catch(e){ /* not JSON, continue to heuristics */ }

                    // fallback: if the text contains PERF_METRICS-like tokens, attempt to extract key numbers
                    const mAvg = txt.match(/"avg_ms"\s*:\s*(\d+(?:\.\d+)?)/i) || txt.match(/PERF_GEN_MS\s*(\d+(?:\.\d+)?)/i);
                    const mMin = txt.match(/"min_ms"\s*:\s*(\d+(?:\.\d+)?)/i);
                    const mMax = txt.match(/"max_ms"\s*:\s*(\d+(?:\.\d+)?)/i);
                    const mCount = txt.match(/"count"\s*:\s*(\d+)/i);
                    const parts = [];
                    if(r.name) parts.push(`Test: ${r.name}`);
                    if(mCount) parts.push(`Runs: ${mCount[1]}`);
                    if(mAvg) parts.push(`Avg: ${mAvg[1]} ms`);
                    if(mMin) parts.push(`Min: ${mMin[1]} ms`);
                    if(mMax) parts.push(`Max: ${mMax[1]} ms`);
                    if(parts.length) return parts.join(' | ');

                    // last resort: short trimmed info
                    const short = txt;
                    return short.length > 300 ? short.slice(0,300)+'...' : short;
                }catch(e){ return String(r.result || 'N/A'); }
            };

            // helper to map type to Chinese labels (性能, 功能, 黑盒, 白盒, 动态, 静态, 其他)
            const mapTestType = (r) => {
                const labels = [];
                try{
                    const n = (r.name || '').toString().toLowerCase();
                    const t = (r.type || r.category || '').toString().toLowerCase();
                    const origin = (r.origin || r.originLabel || '').toString().toLowerCase();
                    if(t.includes('functional') || t.includes('equiv') || t.includes('equivalence') || n.includes('equiv') || n.includes('function') || n.includes('boundary') || t.includes('boundary') || t.includes('check')) labels.push('功能');
                    if(n.includes('perf') || t.includes('perf') || n.includes('performance') || t.includes('performance') || n.includes('throughput') || n.includes('latency') || n.includes('stress') || n.includes('benchmark') || t.includes('benchmark') || t.includes('resource')) labels.push('性能');
                    if((r.category||'').toString().toLowerCase().includes('white') || t.includes('white') || (r.meta||'').toString().toLowerCase().includes('white')) labels.push('白盒');
                    if((r.category||'').toString().toLowerCase().includes('black') || t.includes('black') || (r.meta||'').toString().toLowerCase().includes('black')) labels.push('黑盒');
                    if(origin === 'dynamic' || t.includes('dynamic') || (r.category||'').toString().toLowerCase().includes('dynamic')) labels.push('动态');
                    if(origin === 'static' || t.includes('static') || (r.category||'').toString().toLowerCase().includes('static')) labels.push('静态');
                }catch(e){}
                const uniq = [...new Set(labels)];
                if(uniq.length) return uniq.join(' / ');
                // Prefer showing any explicit type/category/origin provided rather than a generic label
                const fallback = (r.type || r.category || r.origin || r.originLabel) ? String(r.type || r.category || r.origin || r.originLabel) : '未分类';
                return fallback;
            };

            // Group by normalized test name and merge types/status/metrics
            const grouped = {};
            combined.forEach(r => {
                const nameKey = (r.name||'').toString().trim().toLowerCase();
                if(!nameKey) return;
                const mapped = mapTestType(r);
                if(!grouped[nameKey]){
                    grouped[nameKey] = {
                        name: r.name || 'N/A',
                        types: new Set(),
                        origins: new Set(),
                        infos: new Set(),
                        perfValues: [],
                        statuses: new Set()
                    };
                }
                const g = grouped[nameKey];
                // split compound mapped labels like '功能 / 黑盒 / 动态' and add each uniquely
                try{
                    mapped.toString().split('/').map(s=>s.trim()).filter(s=>s).forEach(lbl=>g.types.add(lbl));
                }catch(e){ g.types.add(mapped); }
                if(r.origin) g.origins.add(r.origin);
                if(r.info) g.infos.add(r.info);
                // collect numeric perf: prefer structured JSON in r.info, else fallback to renderPerfInfo
                try{
                    const infoTxt = (r.info||'').toString().trim();
                    if(infoTxt){
                        try{
                            const obj = JSON.parse(infoTxt);
                            if(Array.isArray(obj.measurements_ms)){
                                obj.measurements_ms.forEach(v=>{ if(typeof v === 'number') g.perfValues.push(Number(v)); });
                            } else if(obj.avg_ms!==undefined && obj.count!==undefined){
                                // reconstruct approx measurements from avg
                                g.perfValues.push(Number(obj.avg_ms));
                            }
                        }catch(e){
                            // fallback: see if renderPerfInfo returns single numeric "measurement: NN"
                            const perf = renderPerfInfo(r);
                            if(typeof perf === 'string' && perf.startsWith('measurement:')){
                                const m = perf.match(/measurement:\s*(\d+\.?\d*)/i);
                                if(m) g.perfValues.push(Number(m[1]));
                            }
                        }
                    } else {
                        const perf = renderPerfInfo(r);
                        if(typeof perf === 'string' && perf.startsWith('measurement:')){
                            const m = perf.match(/measurement:\s*(\d+\.?\d*)/i);
                            if(m) g.perfValues.push(Number(m[1]));
                        }
                    }
                }catch(e){}
                g.statuses.add((r.result||'PENDING').toString().toUpperCase());
            });

            // Render grouped rows
            Object.keys(grouped).forEach(k => {
                const g = grouped[k];
                const typeLabel = Array.from(g.types).join(' / ');
                // Determine combined status precedence: FAIL > SKIPPED > PENDING > PASS
                let finalStatus = 'PASS';
                if(Array.from(g.statuses).includes('FAIL')) finalStatus = 'FAIL';
                else if(Array.from(g.statuses).includes('SKIPPED')) finalStatus = 'SKIPPED';
                else if(Array.from(g.statuses).includes('PENDING')) finalStatus = 'PENDING';

                const tr = document.createElement('tr');
                const namec = document.createElement('td'); namec.textContent = safeText(g.name || 'N/A');
                const typec = document.createElement('td'); typec.textContent = safeText(typeLabel || '其他');
                const rescol = document.createElement('td');

                if(typeLabel.indexOf('性能') !== -1 && g.perfValues.length){
                    // show count / avg / min / max
                    const sum = g.perfValues.reduce((a,b)=>a+b,0);
                    const cnt = g.perfValues.length;
                    const avg = (sum/cnt).toFixed(2);
                    const min = Math.min(...g.perfValues);
                    const max = Math.max(...g.perfValues);
                    rescol.textContent = `measurement count: ${cnt}, avg: ${avg} ms, min: ${min} ms, max: ${max} ms`;
                } else {
                    // prefer showing FAIL/SKIPPED/PASS and a short info snippet
                    const infoSnippet = Array.from(g.infos)[0] || '';
                    rescol.textContent = finalStatus + (infoSnippet ? (' — ' + (infoSnippet.length>160?infoSnippet.slice(0,160)+'...':infoSnippet)) : '');
                }

                // attach a small details tooltip combining infos
                if(g.infos.size){
                    const details = Array.from(g.infos).slice(0,8).join('\n---\n');
                    rescol.title = details.length > 0 ? details : '';
                }

                [namec, typec, rescol].forEach(n => tr.appendChild(n));
                tbl.appendChild(tr);
            });
        }

        tableContent.innerHTML = ''; tableContent.appendChild(tbl);
        // hide white/black boxes if table contains test cases
        const wb = document.getElementById('whiteBox');
        const bb = document.getElementById('blackBox');
        if(wb) wb.style.display = 'none';
        if(bb) bb.style.display = 'none';
    } else if(res && res.ui_html){
        tableContent.innerHTML = '<div class="small">'+(res.ui_html||'')+'<div style="margin-top:8px"><a href="ui_report.html" target="_blank">View full report</a></div></div>';
    } else {
        tableContent.textContent = 'No test results available.';
    }

    // Show white/black panels only when we have a processed result but no table rows
    try{
        const wb = document.getElementById('whiteBox');
        const bb = document.getElementById('blackBox');
        if(res){
            if(all.length === 0){
                if(wb) wb.style.display = 'block';
                if(bb) bb.style.display = 'block';
            } else {
                if(wb) wb.style.display = 'none';
                if(bb) bb.style.display = 'none';
            }
        } else {
            // no result yet: keep them hidden
            if(wb) wb.style.display = 'none';
            if(bb) bb.style.display = 'none';
        }
    }catch(e){ /* ignore */ }

    // analysis summaries (show full static result if available)
    try{
        // Prefer structured static results when available (cppcheck + clang-tidy)
        if(res && res.static_structured){
            try{
                const s = res.static_structured;
                const parts = [];
                if(s.cppcheck){
                    parts.push(`cppcheck: ${s.cppcheck.issue_count || 0} issues`);
                }
                if(s.clang_tidy){
                    parts.push(`clang-tidy: ${s.clang_tidy.issue_count || 0} issues`);
                }
                let out = 'Static analysis summary:\n' + parts.join(' | ') + '\n\n';
                // show top lines from each raw report (first 30 lines)
                if(s.cppcheck && s.cppcheck.raw){
                    const lines = (s.cppcheck.raw||'').toString().split('\n').filter(Boolean).slice(0,30);
                    out += '--- cppcheck (top) ---\n' + (lines.join('\n') || '(no output)') + '\n\n';
                }
                if(s.clang_tidy && s.clang_tidy.raw){
                    const lines2 = (s.clang_tidy.raw||'').toString().split('\n').filter(Boolean).slice(0,30);
                    out += '--- clang-tidy (top) ---\n' + (lines2.join('\n') || '(no output)') + '\n\n';
                }
                staticBody.textContent = out;
            }catch(e){ staticBody.textContent = res.static_full || res.static || 'No static results.'; }
        } else if(res && res.static_full){
            staticBody.textContent = res.static_full;
        } else if(res && (res.static || res.static_summary && res.static_summary.raw)){
            staticBody.textContent = (res.static || (res.static_summary && res.static_summary.raw));
        } else {
            staticBody.textContent = 'No static results.';
        }
    }catch(e){ staticBody.textContent = 'No static results.'; }
    dynamicBody.textContent = (res && (res.dynamic_text||res.dynamic_raw||res.dynamic)) ? ( (res.dynamic_text||res.dynamic_raw||res.dynamic).split('\n').slice(0,300).join('\n') ) : 'No dynamic results.';

    const whiteCount = all.filter(t => (t.category||'').toString().toLowerCase().includes('white')).length;
    const blackCount = all.filter(t => (t.category||'').toString().toLowerCase().includes('black')).length;
    whiteBody.textContent = `White-box tests: ${whiteCount}.`;
    blackBody.textContent = `Black-box tests: ${blackCount}.`;

    lastUpdated.textContent = new Date().toLocaleString();

    // Inline full static analysis when available (avoid short header noise)
    try{
        if(res && res.static_full){
            staticBody.textContent = res.static_full;
        } else if(res && (res.static || (res.static_summary && res.static_summary.raw))){
            staticBody.textContent = res.static || (res.static_summary && res.static_summary.raw);
        } else {
            staticBody.textContent = 'No static results.';
        }
    }catch(e){ staticBody.textContent = 'No static results.'; }

    // Prepend a concise numeric summary (total + per-tool) when available
    try{
        let cppCount = 0, tidyCount = 0, totalCount = null;
        if(res && res.static_structured){
            try{ cppCount = Number((res.static_structured.cppcheck && res.static_structured.cppcheck.issue_count) || 0); }catch(e){ cppCount = 0; }
            try{ tidyCount = Number((res.static_structured.clang_tidy && res.static_structured.clang_tidy.issue_count) || 0); }catch(e){ tidyCount = 0; }
            totalCount = (typeof res.static_count !== 'undefined' && res.static_count !== null) ? Number(res.static_count) : (cppCount + tidyCount);
        } else if(res && typeof res.static_count !== 'undefined'){
            totalCount = Number(res.static_count) || 0;
        }
        if(totalCount !== null){
            const summaryLine = ` Static Issues: ${cppCount}\n\n`;
            staticBody.textContent = summaryLine + (staticBody.textContent || '');
        }
    }catch(e){ /* ignore */ }
}

async function pollStatus(ws){
    try{
        const r = await fetch('/status?ws='+encodeURIComponent(ws));
        const d = await r.json();
        // update progress if provided
        if(d && (typeof d.progress === 'number')){
            setProgress(d.progress, d.message || d.status || 'Processing');
        } else if(d && d.status){
            setProgress(60, d.status);
        }
        if(d && (d.status==='Done' || d.status==='done')){ renderResult(d.result||d); setProgress(100, 'Complete'); return true; }
    }catch(e){ console.error('pollStatus', e); setProgress(0,'Error'); }
    return false;
}

uploadBtn.addEventListener('click', async ()=>{
    if(!fileInput.files.length) return alert('Choose a zip first');
    uploadBtn.disabled = true; uploadBtn.textContent = 'Uploading...'; setProgress(10,'Uploading...');
    const fd = new FormData(); fd.append('file', fileInput.files[0]);
    try{
        const r = await fetch('/upload', { method:'POST', body: fd });
        const j = await r.json();
        if(!j || j.status!=='Accepted' || !j.workspace){ alert('Upload failed'); uploadBtn.disabled=false; uploadBtn.textContent='Upload & Analyze'; return; }
        const ws = j.workspace; setProgress(30,'Queued'); let done=false; const iv = setInterval(async ()=>{ done = await pollStatus(ws); if(done){ clearInterval(iv); uploadBtn.disabled=false; uploadBtn.textContent='Upload & Analyze'; setProgress(100,'Complete'); } }, 1500);
    }catch(e){ alert('Upload error: '+e); uploadBtn.disabled=false; uploadBtn.textContent='Upload & Analyze'; }
});
</script>
</body>
</html>
